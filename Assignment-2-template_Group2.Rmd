

# INSTRUCTIONS

-   This is a group assignment.
-   Submit your answer digitally as two files through Moodle:
    -   An R markdown file (extension **Rmd**). Use the template provided
        to you and provide your answers (both code and text) below each
        question.
    -   An **HTML** file "knitted" by RStudio including all the results and
        plots. More details on how to create these files will be provided
        in class on week 3.
-   Follow the Style Guide (available on Moodle). You can be
    penalized on up to 20% in each question for which you do not follow
    the Style Guide.
-   Questions regarding the assignment should be posted <span class="underline">exclusively</span> on
    the respective discussion forum on Moodle.
-   **Deadline:** 25 February 2024 23:59    


<span class="underline">**Warning:**</span> The detection of <span class="underline">any form of plagiarism</span> in your work
means the assignment will be graded with <span class="underline">ZERO points</span>.

\newpage


# Movie Networks

We are interested in assessing what are the most important movies in
the decade 2010-2019. We will use different strategies to do so.
First, we will load and prepare the data.


## Load and prepare the data

The first step is to load and prepare the movie data. The following
instructions perform some routine data preparation operations. Each
set of instructions is preceded by a comment explaining the procedure.
Run the code below and try to understand each line of code as you
might need to perform some changes.

```{r   }
library(data.table)     # Run once per session
library(ggplot2)        # Run once per session

# Load data from file 20200120-imdb_movie_actor.csv (do not forget to
# change your working directory to the folder containing the
# 20200120-imdb_movie_actor.csv file)
dt.movie.actor <- fread("20200120-imdb_movie_actor.csv") 

# Count in how many movies each actor has participated and how many 
# principal actor each movie has
dt.movie.actor[, n_movies := .N, by=actor]
dt.movie.actor[, n_actors := .N, by=list(movie, year)]

# Remove entries in which actors have no name 
dt.movie.actor <- dt.movie.actor[!(actor == "")]

# Save dt.movie.actor. Next time you can simply call the load function (below)
save(dt.movie.actor, file="imdb_movie_actor.RData") 
```

Load the data that you prepared using the instructions below. As mentioned in the
comments, you can start from this line if you have previously saved these data.

```{r   }
# Load previously saved dt.movie.actor. You can
# start in this line if you have previously saved these data.
load("imdb_movie_actor.RData") 
```


## Questions (`data.table`) `[7 points]`

This set of questions require that you know how to manipulate a
`data.table`. Answer each of the following questions below. Include
all the code you created/used in your answer.

1.  What is the total amount of movies in the `dt.movie.actor` dataset?
    `[1 point]`

```{r}
length(unique(dt.movie.actor$movie))
```


2.  List the actors from the movie `"Fight Club (1999)"`. List
    the actors from the movie `"Se7en (1995)"`. `[1 point]`

```{r}
print("A) Here below are the actors from Fight Club (1999):")
for (act in dt.movie.actor[dt.movie.actor$movie=="Fight Club (1999)","actor"]){
  print(paste0("  - ",act))
}

print("B) Here below are the actors from Se7en (1995):")
for (act in dt.movie.actor[dt.movie.actor$movie=="Se7en (1995)","actor"]){
  print(paste0("  - ",act))
}
```

3.  Which actors participated on both movies? Hint: The function
    `intersect` calculates the intersection of two sets. `[1 point]`

```{r}
fight_club_actors <- dt.movie.actor[movie == "Fight Club (1999)", actor]
se7en_actors <- dt.movie.actor[movie == "Se7en (1995)", actor]

intersect(fight_club_actors, se7en_actors)
```

4.  In which movies did Brad Pitt (b.1963) and George Clooney (b.1961) star together?
    `[1 point]`

```{r}
print("Brad Pitt (b.1963) and George Clooney (b.1961) star together in:")
BP.and.GC <- intersect(
  dt.movie.actor[dt.movie.actor$actor=="Brad Pitt (b.1963)",]$movie,
  dt.movie.actor[dt.movie.actor$actor=="George Clooney (b.1961)",]$movie
)
for (mov in BP.and.GC){
  print(paste0("  - ",mov))
}
```

5.  Create a table that shows the number of movies released per year.
    This table should include three columns: `year`, `n_movies`, and
    `csum_n_movies`. The first column should contain the year, the
    second the number of movies in that year, and the third, the number
    of movies released since the first year in the data and up to the
    year in that line. Tip: Use the function `cumsum` and check if the
    amount in the last year is the same as the total number of movies
    in question 1. `[1 point]`

```{r}
yearly_summary <- dt.movie.actor[, list(
  n_movies = uniqueN(movie)), by=year]
# We order the years before making the cumulative sum
yearly_summary <- yearly_summary[order(year),]
yearly_summary$csum_n_movies <- cumsum(yearly_summary$n_movies)
yearly_summary
```

6.  Which actor/actress has starred in the most movies across all data?
    After (and including) 2000, which year has the most movie
    participations by a single actor/actress? Who is that
    actor/actress? What do these two actors/actresses have in common?
    `[1 point]`

```{r}
actor_movie_count <- dt.movie.actor[, .(n_movies = .N), by = .(actor)]
actor_movie_count <- actor_movie_count[order(-n_movies)]

actor_movie_count[1,]

###############################

after2000 <- dt.movie.actor[year >= 2000]
count_participations <- after2000[, .(n_participations = .N), by = .(year, actor)]
top_year <- count_participations[order(-n_participations), .(year, actor, max_participations = n_participations)] [1]

top_year

```
Both `r dt.movie.actor[order(n_movies, decreasing=TRUE), ][[1,"actor"]]` and `r summarize.after.2000[order(movie_part, decreasing=TRUE),][1,"actor"]` are indian male actors.


7.  Consider only the 10% most popular movies (by votes) in the decade 2010-2019.
    List the top 10 actors that starred in the most movies in the decade.
    Which year(s) has/have the most movie participations by a single actor?
    Hint: you can use the function `quantile` to find how many votes
    does the movie in percentile 90 have. `[1 point]`


```{r}
# 1. Filter for the right decade
movies.10.19 <- dt.movie.actor[year >= 2010 & year <= 2019,]
# 2. Find the 90th percentile for individual movies
individual.movies <- movies.10.19[, list(votes = max(votes)), by=list(movie)]
percentile.90 <- quantile(individual.movies$votes, probs = seq(0,1,0.1), na.rm=TRUE)[10]
# 3. Filter the top movies
movies.10.19.top <- movies.10.19[votes >= percentile.90,]
# 4. List the top 10 actors that starred in the most movies in the decade
n_movies_decades <- movies.10.19.top[, list(movies= .N), by=actor]
n_movies_decades[order(movies, decreasing=TRUE),][1:10,]

# 5. Find the year/years in which a single actor starred in the most movies
n_movies_year <- movies.10.19.top[, list(movies= .N), by=list(year,actor)]
print(paste0(
  "The years having the most movie participations by a single actor (",
  max(n_movies_year$movies)," participations) are: "))
sort(unique(n_movies_year[movies == max(movies),]$year))
```

## Questions (`ggplot2`) `[3 points]`

1.  Plot a histogram with the number of movies per year. Which patterns
    do you observe? Is there anything strange? `[1 point]`

```{r}
ggplot(yearly_summary, aes(x = year, y = n_movies)) + 
geom_histogram(bins = 50, stat = "identity") +
xlab("Year") + ylab("Movies per year") +
ggtitle("Histogram of the number of movies per year")
```
The pattern observed is a steep rise in the number of movies from 2000 onward, with a significant increase in successive bins. This suggest a noticeable trend in the film industry, indicating a surge in movie production, possibly due to advancements in technology, increased globalization of the film industry, and changes in distribution channels (streaming platforms).

2.  Plot a histogram that represents the distribution of number of IMDb
    votes per movie. The x-axis should represent the number of votes
    and the y-axis should represent how many movies have x number of
    votes. Which patterns do you observe? `[1 point]`

```{r}
ggplot(individual.movies, aes(x = votes)) + geom_histogram(binwidth = 30000, color = "black", fill = "blue") + xlab("Number of IMDb Votes") + ylab("Number of Movies") + ggtitle("Distribution of IMDb Votes per Movie")
```
We will plot the histogram again but with a logarithmic scaling on the x axis to make it readable. In fact we see that a few outliers have a huge amount of vote and skew the whole distribution to the right. Also note that the movies with no votes information are removed from the visualization.

```{r}
ggplot(votes_individual_movies, aes(x=votes)) + geom_histogram(bins=50) +
  ggtitle("Histogram of the number of IMDb votes per movie") + scale_x_log10() +
  xlab("Logarithm of the IMDb votes") + ylab("Number of movies")
```

3.  Plot a histogram that represents the distribution of the number of
    actors per movie. The x-axis should represent the number of actors
    and the y-axis should represent how many movies have x number of actors.
    Describe your findings. `[1 point]`

```{r}
ggplot(votes_individual_movies, aes(x=n_actors)) + geom_histogram(bins=50) +
  geom_text(stat = "count", aes(label = ..count..), vjust = -0.5, size = 2) + scale_x_continuous(breaks = seq(0, 25, by = 1)) +
  ggtitle("Histogram of the number of actors per movie") +
  xlab("Number of actors in the movie") + ylab("Number of movies")

```

We see that the majority of movies star 4 actors. For the movies that don't, the distribution is quite uniform between one and 7 and starts decreasing until 10. A few movies have a much higher number of actors (up to `r max(votes_individual_movies$n_actors)`).

## Questions (`igraph`) `[10 points]`

1.  From this question onwards, and until the end of the assignment,
    focus only on <span class="underline">the actors that participated on the top 50 most
    popular movies from the 2010-2019 decade (by number of votes).</span>
    Load the `igraph` package and create a bipartite graph in which the
    edges correspond to actors&rsquo; participation in movies. How many movie
    participations exist? `[1 point]`
    
```{r}
library(igraph)

# We keep only the top 50 movies (with no duplicates) movies from the decade
top50_movies <- individual.movies[order(votes, decreasing = TRUE),][1:50,"movie"]
dt.igraph <- movies.10.19[movie %in% top50_movies$movie]

# We update the number of movies for this particular decade.
dt.igraph[, n_movies := .N, by=actor]

# We create the bipartite graph
all.actors <- dt.igraph[, list(name=unique(actor), type=TRUE)]
all.movies <- dt.igraph[, list(name=unique(movie), type=FALSE)]

all.vertices <- rbind(all.actors,all.movies)
g <- graph.data.frame(dt.igraph[, list(movie,actor)], directed = FALSE,
                      vertices=all.vertices)
summary(g)
top50_movies
plot(g, vertex.size = 5, vertex.label = NA)
```


2.  Create a graph in which two movies are connected to each other if
    they have <span class="underline">at least one actor in common</span>. Calculate the <span class="underline">degree
    centrality</span> for each of the movies, and remove movies with no
    connections to other movies. <span class="underline">Hint:</span> the function
    `induced.subgraph` allows the creation of graphs with only a subset
    of the vertices. Calculate the following additional centrality
    measures for each of these movies: `[2 points]`
    -   Closeness centrality
    -   Betweenness centrality
    -   Eigenvector centrality

```{r}
g.movies <- bipartite.projection(g)$proj1

# We compute the degree centrality and other
V(g.movies)$degree <- degree(g.movies)

# We remove the vertices that are not connected to any other
g.movies.connected <- induced.subgraph(g.movies, vids=V(g.movies)$degree > 0)
# We could also have removed vertices that have no edges
# g.movies.connected <- subgraph.edges(
  # g.movies, eids=E(g.movies), delete.vertices = TRUE)
summary(g.movies.connected)
plot(g.movies.connected, vertex.size=5, vertex.label=NA)

# We then compute the other centrality measures
V(g.movies.connected)$closeness <- closeness(g.movies.connected)
V(g.movies.connected)$betweenness <- betweenness(g.movies.connected)
V(g.movies.connected)$evcent <- evcent(g.movies.connected)$vector
```

3.  For each centrality measure, list the top 20 movies with highest
    centrality. How do you interpret the outcomes? `[2 points]`

```{r}
dt.g.movies <- data.table(get.data.frame(g.movies.connected, "vertices"))

dt.g.movies[order(-degree),][1:20,]
dt.g.movies[order(-closeness),][1:20,]
dt.g.movies[order(-betweenness),][1:20,]
dt.g.movies[order(-evcent),][1:20,]
```
**General Interpretation**: the Marvel movies are very central. In fact, the actors of the various superheroes appear in all the different movies as they always embody the same characters. For example `Chris Evans (b.1981)` (Captain America) and `Robert Downey Jr. (b.1965)` (Iron man) appear in 7 movies each in that decade. Besides, the movies staring `Leonardo DiCaprio (b.1974)` also have had a lot of success and we see 5 of them in the top 50 that are therefore connected (Shutter Island, The Revenant, or Inception for instance).

3.1. **Degree centrality**: the `Avengers` movies are the best connected because the gather all the superheroes and are connected by the actors who embody them. `Shutter Island` also falls in the top because it stars `Mark Ruffalo` who connects the movie to most the Marvels, and `Leonardo DiCaprio` who starred in a lot of successful movies too.

3.2. **Closeness centrality**: the movies staring `Jennifer Lawrence` are very close to other nodes because she makes the junction between the `X-Men universe`, the `Hunger Games`, and other successful movies such as the `Silver Linings Playbook`. These various movies give access to a range of other nodes easily.

3.3. **Betweenness centrality**: `Shutter Island` seems to be the movie through which other movies have to pass the most to be connected to other movies. This might be due to the fact that it stars 
both `Leonardo DiCaprio` and `Mark Ruffalo` and is therefore an easy bridge between all the DiCaprio movies and the Marvel universe. Similarly, `Now You See Me` can make the bridge between the Batman series and the Social Network with `Jesse EisenBerg` and with the Marvel and DiCaprio movies through `Mark Ruffalo`.

3.4. **Eigenvector centrality**: similarly to the degree centrality, the `Avengers` movies are the most important as they are connected to a lot of movies that are important themselves as they star actors that come back often in the top 50 movies. The four avengers are connected together and connected to many more and that can already help explain their importance.


4.  Calculate the average clustering coefficient for the movies
    network. `[1 point]`

```{r}
transitivity(g.movies.connected, type="average")
```

5.  Choose one movie you like and plot the movie, their direct
    neighbors and the links among them. What is the clustering
    coefficient of this movie? Which is the actor with most
    participations among these (neighbor) movies, but not having
    participated in the movie itself? `[2 points]`

```{r}
# Let's go with Shutter Island (2010)

shutter.island.neighbors <- neighbors(
  g.movies.connected, "Shutter Island (2010)")

g.shutter.island <- induced.subgraph(
  g.movies.connected, V(g.movies.connected)$name %in% c(
    shutter.island.neighbors$name,"Shutter Island (2010)"))
V(g.shutter.island)$label.cex = 0.8


plot(g.shutter.island, vertex.size=5)


#-------------------------------------------------------------------------------


V(g.movies.connected)$clustering <- transitivity(
  g.movies.connected, type="local")

V(g.movies.connected)[name=="Shutter Island (2010)"]$clustering


#-------------------------------------------------------------------------------

actors.shutter.island <- movies.10.19[movie=="Shutter Island (2010)"]$actor
movies.10.19[
  movie %in% shutter.island.neighbors$name & !(
  actor %in% actors.shutter.island), list(n_movies=.N), by=actor
][n_movies==max(n_movies)]
```
We have a tie between `Robert Downey Jr. (b.1965)`, `Chris Evans (b.1981)`, and `Chris Hemsworth (b.1983)` who all took part in the three Avengers.


6.  Plot the degree distribution of the movies. How do you compare them
    with the degree distribution of a random graph? What can be
    plausible explanations for the observed differences? `[2 points]`


```{r}
# Actual Graph
ggplot() + geom_histogram(aes(x=V(g.movies)$degree)) +
  ggtitle("Degree distribution of all the movies (also those not connected)") +
  xlab("Degree Connection") + ylab("Number of Movies")

# Random Graph
summary(g.movies)
g.sam <- sample_gnm(50,80)
ggplot() + geom_histogram(aes(x=degree(g.sam))) +
  ggtitle("Degree distribution of a random graph") +
  xlab("Degree Connection") + ylab("Number of Movies")
```

We observe that the distribution of the random graph follows a bell shape where as in reality, we have fatter tails. In fact, out of our top 50 movies, 12 have no common actors with any others (fat left tail). We also see that 3 movies have 11 connections (fat right tail). We therefore see two different kind of successful movies that don't appear in the theoretical random distribution:

- *The outliers*: Many movies that become very successful are unique and uncover new and talented actors that are revelations to the public. These unique movies are therefore not very connected to the others and form that fat left tail.
- *The series*: On the other end of the spectrum, we have the Marvel series. We take the same characters, the same actors, and the same 'recipe'. It is a successful combination that is reused over and over again to created blockbusters. These movies are very connected as they star the same actors and have continuities in their plots. These 'series' form the right tail of the degree distribution.